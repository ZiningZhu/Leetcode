class Solution(object):
    def nearestPalindromic(self, n):
        """
        :type n: str
        :rtype: str
        Find the closest (as in absolute difference) palindrome of an integer (represented in string). The result **shall not include itself!**
        This solution is based on the following greedy algorithm: changing the bits from LSB to halfway one by one. If a palindrome is found, then this is the smallest difference one ever found.
        In other word: the prefix (highest bits) determine the palindrome uniquely.
        A corner case is 10000. This algorithm finds 10001 but should be 9999.
        To cover this corner case, put the palindrome generated by flipping (prefix-1, prefix, prefix+1) into a candidate list. Return the one with smallest abs difference (the smaller if there are multiple).
        """
        def absdiff(s1, s2):
            diff = int(s1) - int(s2)
            if diff < 0:
                diff = -diff
            return diff

        def flip(prefix, isodd):
            ans = prefix
            if not isodd:
                ans += prefix[::-1]
            else:
                ans += prefix[:-1][::-1]
            return ans

        candidates = []
        if len(n) == 1:
            return str(int(n)-1)

        m = (len(n)+1) // 2
        if len(n) % 2 == 1:
            isodd = True
        else:
            isodd = False
        P = n[:m]

        if int(P) == ((10 ** len(P))-1):
            candidates.append(flip(str(int(P)-1), isodd))
            candidates.append(flip(str(int(P)), isodd))
            candidates.append(flip(str(int(P)+1)[:-1], not isodd) if isodd else flip(str(int(P)+1), not isodd))
        elif int(n) - (10 ** (len(n)-1)) <= 1: # n = 1000 or 1001
            candidates.append(str(10 ** (len(n)-1) -1)) # Append 999
            candidates.append(flip(str(int(P)), isodd))
            candidates.append(flip(str(int(P)+1), isodd))
        else:
            candidates.append(flip(str(int(P)-1), isodd))
            candidates.append(flip(str(int(P)), isodd))
            candidates.append(flip(str(int(P)+1), isodd))

        print ("n={}, candidates={}".format(n, candidates))
        minabsdiff = None
        respal = None

        for c in candidates:
            tmp = absdiff(c, n)
            #print ("n={}, c={}, absdiff={}".format(n,c,tmp))
            if tmp == 0:
                continue
            if (respal == None) or (tmp < minabsdiff) or (tmp == minabsdiff and int(c) < int(respal)):
                respal = c
                minabsdiff = tmp

        return respal

if __name__ == "__main__":
    s = Solution()
    print ("Should be -1: {}".format(s.nearestPalindromic("0")))
    print ("Should be 121: {}".format(s.nearestPalindromic("123")))
    print ("Should be 12321: {}".format(s.nearestPalindromic("12345")))

    print ("Should be 1001: {}".format(s.nearestPalindromic("999")))
    print ("Should be 101: {}".format(s.nearestPalindromic("99")))
    print ("Should be 9: {}".format(s.nearestPalindromic("10")))
    print ("Should be 9999: {}".format(s.nearestPalindromic("10000")))
    print ("Should be 999: {}".format(s.nearestPalindromic("1001")))
    print ("Should be 9999: {}".format(s.nearestPalindromic("10001")))
    print ("Should be 999: {}".format(s.nearestPalindromic("1000")))
    print ("Should be 9999: {}".format(s.nearestPalindromic("10000")))
